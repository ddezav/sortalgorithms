# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HaRc3-zumf3MFqxTemFVreRLynnUCKMo
"""

from math import log       # import done only to use logarithm
import numpy as np         # import done to use of calculation, arrays
import matplotlib.pyplot as plt   # import done only to use graphics
import datetime
import time
from numpy.random import seed
from numpy.random import rand

import sys

# Python3 program to sort an array 
# using bucket sort 
def insertionSort(b):
    for i in range(1, len(b)):
        up = b[i]
        j = i - 1
        while j >= 0 and b[j] > up: 
            b[j + 1] = b[j]
            j -= 1
        b[j + 1] = up     
    return b     
              
def bucketSort(x):
    arr = []
    slot_num = 10 # 10 means 10 slots, each
                  # slot's size is 0.1
    for i in range(slot_num):
        arr.append([])
          
    # Put array elements in different buckets 
    for j in x:
        index_b = int(slot_num * j) 
        arr[index_b].append(j)
      
    # Sort individual buckets 
    for i in range(slot_num):
        arr[i] = insertionSort(arr[i])
          
    # concatenate the result
    k = 0
    for i in range(slot_num):
        for j in range(len(arr[i])):
            x[k] = arr[i][j]
            k += 1
    return x
  
# Driver Code
x = [0.897, 0.565, 0.656,
     0.1234, 0.665, 0.3434] 
print("Sorted Array is")
print(bucketSort(x))

def mergeSort(arr):
    if len(arr) > 1:
 
         # Finding the mid of the array
        mid = len(arr)//2
 
        # Dividing the array elements
        L = arr[:mid]
 
        # into 2 halves
        R = arr[mid:]
 
        # Sorting the first half
        mergeSort(L)
 
        # Sorting the second half
        mergeSort(R)
 
        i = j = k = 0
 
        # Copy data to temp arrays L[] and R[]
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                arr[k] = L[i]
                i += 1
            else:
                arr[k] = R[j]
                j += 1
            k += 1
 
        # Checking if any element was left
        while i < len(L):
            arr[k] = L[i]
            i += 1
            k += 1
 
        while j < len(R):
            arr[k] = R[j]
            j += 1
            k += 1

# Function to find the partition position
def partition(arr, l, h):
  low, high = l, h
  if l != h and l < h:
    # Choose the leftmost element as pivot
    pivot = arr[l]
    low = low+1
    # Traverse through all elements
    # compare each element with pivot
    while low <= high:
      if arr[high] < pivot and arr[low] > pivot:
        arr[high], arr[low] = arr[low], arr[high]
      if not arr[low] > pivot:
        low += 1
      if not arr[high] < pivot:
        high -= 1
  arr[l], arr[high] = arr[high], arr[l]
  # Return the position from where partition is done
  return high
  
# Function to perform quicksort
def quick_sort(array, low, high):
  if low < high:
  
      # Find pivot element such that
      # element smaller than pivot are on the left
      # element greater than pivot are on the right
      pi = partition(array, low, high)
  
      # Recursive call on the left of pivot
      quick_sort(array, low, pi - 1)
  
      # Recursive call on the right of pivot
      quick_sort(array, pi + 1, high)
  
  
          
# Driver code
array = [ 1, 7, 8, 9, 1, 2]
quick_sort(array, 0, len(array) - 1)
  
print(f'Sorted array: {array}')

def insertionSort(arr):
  
    # Traverse through 1 to len(arr)
    for i in range(1, len(arr)):
  
        key = arr[i]
  
        # Move elements of arr[0..i-1], that are
        # greater than key, to one position ahead
        # of their current position
        j = i-1
        while j >= 0 and key < arr[j] :
                arr[j + 1] = arr[j]
                j -= 1
        arr[j + 1] = key
  
  
# Driver code to test above
arr = [12, 11, 13, 5, 6]
insertionSort(arr)

def heapify(arr, N, i):
    largest = i  # Initialize largest as root
    l = 2 * i + 1     # left = 2*i + 1
    r = 2 * i + 2     # right = 2*i + 2
 
    # See if left child of root exists and is
    # greater than root
    if l < N and arr[largest] < arr[l]:
        largest = l
 
    # See if right child of root exists and is
    # greater than root
    if r < N and arr[largest] < arr[r]:
        largest = r
 
    # Change root, if needed
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # swap
 
        # Heapify the root.
        heapify(arr, N, largest)
 
# The main function to sort an array of given size
 
 
def heapSort(arr):
    N = len(arr)
 
    # Build a maxheap.
    for i in range(N//2 - 1, -1, -1):
        heapify(arr, N, i)
 
    # One by one extract elements
    for i in range(N-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]  # swap
        heapify(arr, i, 0)
 
 
# Driver's code
if __name__ == '__main__':
    arr = [12, 11, 13, 5, 6, 7]
 
    # Function call
    heapSort(arr)
    N = len(arr)
 
    print("Sorted array is")
    for i in range(N):
        print("%d" % arr[i], end=" ")

seed(1)
# generate random numbers between 0-1
def pruebaIteracion(numero,dataInsert,dataMerge,dataQuick,dataHeap):
  dataMerge = [numero]
  dataQuick = [numero]
  dataInsert = [numero]
  dataHeap = [numero]
  data = np.ones(nDatos) * numero 

  data = data.astype(int)     

 
  for i in data:
    arr = rand(i)
    t = time.time()
    arr1 = arr
    insertionSort(arr1)
    fin = time.time() -t 
    dataInsert.append(fin)
  for i in data:
    arr = rand(i)
    arr1 = arr
    t = time.time()
    mergeSort(arr1)
    fin = time.time() -t 
    dataMerge.append(fin)


    sys.setrecursionlimit(3000)


  for i in data:
    arr = rand(i)

    t = time.time()
    quick_sort(arr,0, len(arr) - 1)
    fin = time.time() -t 
    dataQuick.append(fin)
  for i in data:
    arr = rand(i)

    t = time.time()
    heapSort(arr)
    fin = time.time() -t 
    dataHeap.append(fin)

  
  return dataInsert,dataMerge,dataQuick,dataHeap

seed(1)
import statistics

# generate random numbers between 0-1
i = 0
dMergeTot = []
dQuickTot = []
dInsertTot = []
dHeapTot = []
nDatos = 10
dataNumeros =[ 50, 60, 70, 80, 90, 100, 200, 300, 400 ,500, 600,700,2000]
for x in dataNumeros:
  dataMerge = []
  dataQuick = []
  dataInsert = []
  dataHeap = []

  dataInsert,dataMerge,dataQuick,dataHeap = pruebaIteracion(x,dataInsert,dataMerge,dataQuick,dataHeap)
  
  dMergeTot.append(dataMerge)
  dQuickTot.append(dataQuick)
  dInsertTot.append(dataInsert)
  dHeapTot.append(dataHeap)
  i = i + 1

dMerge=np.array(dMergeTot)
dQuick=np.array(dQuickTot)
dInsert=np.array(dInsertTot)
dHeap=np.array(dHeapTot)
import statistics
print (dMerge.shape)
list =  [1, 2, 3, 4, 5, 6]
dMergeProm = []
dQuickProm = []
dInsertProm = []
dHeapProm = []

dMerge
np.savetxt("foo.csv", dMerge, delimiter="\t")



import sys
print(sys.getrecursionlimit())

# Constant Function
# Created array of 100 position whith values 1 until 10.

#Linear Function
n = np.linspace(1, 10, 100) # random value

#Constant Function
big_o_const = np.ones(n.shape)

#Logarithmic Function
big_o_log = np.log(n)

#Logarithmic Linear Function
big_o_log_linear = n*big_o_log

#Quadratic Function
big_o_quadratic = n**2

#Cubic Function
big_o_cubic = n**3

#Exponential Function
big_o_exponential = 2**n

arr = [12, 11, 13, 5, 6, 7]
    print("Given array is", end="\n")
    printList(arr)
    mergeSort(arr)
    print("Sorted array is: ", end="\n")
    printList(arr)

labels = [ 'merge', 'quic']
big_o = [dataMerge, dataQuick]
print (dataMerge)
print (dataQuick)
print (dataInsert)

plt.figure(figsize=(10,8))
t = np.arange(0., 5., 0.2)
dataMerge2 = np.array(dataMerge)

# red dashes, blue squares and green triangles
plt.plot(data, dataMerge2, 'r', data, dataQuick, 'b',data, dataInsert, 'g')
plt.show()
plt.legend()
plt.ylabel('Runtime')
plt.xlabel('n')

